#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <windows.h>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#undef max

bool check_valid(int& req_cells, const std::string& input, const std::string& fname);
inline void syntax_err(const std::string& message, const std::string& fname, const int& line, const int& pos);
void replace(std::string& target, const std::string& oldstr, const std::string& newstr);
std::string rstring(int len = 10);

class stack {
	public:
		stack(): p_top(0) {}
		void push(std::string val) {
			if(p_top >= 500) return;
			data[p_top] = val;
			++p_top;
		}
		std::string pop() {
			if(p_top <= 0) return "";
			--p_top;
			return data[p_top];
		}
		std::string top() const {
			return data[p_top - 1];
		}
	private:
		std::string data[500];
		int p_top;
};

int main(int argc, char *argv[]) {
	std::string date;
	{
		time_t timestamp = time(0);
		char t_date[26];
		ctime_s(t_date, 26, &timestamp);
		srand((unsigned int)timestamp);
		date = t_date;
	}
	HWND c_hwnd;
	{
		char title[500];
		GetConsoleTitle(title, 500);
		c_hwnd = FindWindow(0, title);
	}
	std::string input;
	std::string target_file;
	{
		if(argc == 1) {
			std::cout << "Enter file path: ";
			std::cin >> target_file;
		}
		else {
			target_file = argv[1];
		}
		target_file[1] = ':';
		std::ifstream fp(target_file.c_str());
		if(!fp.is_open()) {
			std::cerr << "File does not exist, or some other error occurred.\n";
			return 1;
		}
		std::string tinput = "";
		while(std::getline(fp, tinput)) input += tinput + "\n";
		fp.close();
	}
	std::cout << "Compiling \"" << target_file << "\"...\n";
	std::cout << "\tChecking for errors.\n";
	int max = 0;
	if(check_valid(max, input, target_file)) {
		std::cout << "\tNo errors found.\n";
	}
	else {
		std::cout << "\tErrors were found; stopping compilation.\n";
		return 1;
	}
	std::string incl_path(argv[0]);
	int i;
	for(i = incl_path.size(); i > 0; --i) {
		if(incl_path[i] == '\\') break;
	}
	std::string path;
	incl_path.erase(i + 1);
	path = incl_path;
	incl_path += "include\\win32ax.inc";
	std::cout << "\tCleaning up previous compilation...\n";
	std::remove((path + "output.asm").c_str());
	std::remove((path + "output.exe").c_str());
	std::cout << "\tGenerating code...\n";
	std::stringstream output;
	output << ";generated by BFCompiler v0.1 on " << date << "\n";
	output << "include \'" << incl_path << "\'\n.data\ninchar DB ?\nnumwritten DD ?\nnumread DD ?\nouthandle DD ?\ninhandle DD ?\n\n";
	for(i = 0; i <= max; ++i) {
		output << "cell" << i << " DB 0\n";
	}
	output << ".code\nstart:\n.init:\ninvoke AllocConsole\ninvoke GetStdHandle,STD_OUTPUT_HANDLE\nmov [outhandle],eax\n";
	output << "invoke GetStdHandle,STD_INPUT_HANDLE\nmov [inhandle],eax\n.program:\n";
	//TODO: Optimise BF code
	int cell = 0;
	stack loop;
	for(i = 0; (unsigned)i < input.size(); ++i) {
		switch(input[i]) {
			case '+': {
					int j = i;
					for(++i; (input.at(i) != '<' && input.at(i) != '>' && input.at(i) != '[' && input.at(i) != ']' &&
							  input.at(i) != ',' && input.at(i) != '.' && input.at(i) != ',' && input.at(i) != '-')
							  && (unsigned)i < input.size(); ++i) {
								  if(input.at(i) != '+') {
									  ++j;
								  }
					}
					--i;
					--j;
					output << "add [cell" << cell << "]," << i - j << "\n";
				}
				break;
			case '-': {
					int j = i;
					for(++i; (input.at(i) != '<' && input.at(i) != '>' && input.at(i) != '[' && input.at(i) != ']' &&
							  input.at(i) != ',' && input.at(i) != '.' && input.at(i) != ',' && input.at(i) != '+')
							  && (unsigned)i < input.size(); ++i) {
								  if(input.at(i) != '-') {
									  ++j;
								  }
					}
					--i;
					--j;
					output << "sub [cell" << cell << "]," << i - j << "\n";
				}
				break;
			case '>':
				++cell;
				break;
			case '<':
				--cell;
				break;
			case '[':
				loop.push(rstring());
				output << ".lp" << loop.top() << ":\n";
				break;
			case ']':
				output << "cmp [cell" << cell << "],0\n";
				output << "jne .lp" << loop.pop() << "\n";
				break;
			case '.':
				output << "invoke WriteConsole,[outhandle],cell" << cell << ",1,numwritten,0\n";
				break;
			case ',':
				output << "invoke ReadConsole,[inhandle],cell" << cell << ",1,numread,0\n";
				break;
		}
	}
	output << ".exit:\n";
	output << "invoke ReadConsole,[inhandle],inchar,1,numread,0\n";
	output << "invoke ExitProcess,0\n.end start";
	{
		std::cout << "\tBeginning optimisations...\n";
		std::string temp = output.str();
		for(int k = 0; k <= max; ++k) {
			std::stringstream tmp1, tmp2;
			tmp1 << "sub [cell" << k << "],1";
			tmp2 << "dec [cell" << k << "]";
			replace(temp, tmp1.str(), tmp2.str());
			tmp1.clear();
			tmp2.clear();
			tmp1 << "add [cell" << k << "],1";
			tmp2 << "inc [cell" << k << "]";
			replace(temp, tmp1.str(), tmp2.str());
			tmp1.clear();
			tmp2.clear();
			tmp1 << "dec [cell" << k << "]\ncmp [cell" << k << "],0\njne";
			tmp2 << "dec [cell" << k << "]\njnz";
			replace(temp, tmp1.str(), tmp2.str());
			for(int l = 2; l < 256; ++l) {
				tmp1.clear();
				tmp2.clear();
				tmp1 << "sub [cell" << k << "]," << l << "\ncmp [cell" << k << "],0\njne";
				tmp2 << "sub [cell" << k << "]," << l << "\njnz";
				replace(temp, tmp1.str(), tmp2.str());
			}
		}
		output.str(temp);
		std::cout << "\tOptimisations complete.\n";
	}
	std::cout << "Code generation complete. Executable saved at " << path << "output.exe.\n";
	std::cout << "Assembly output (saved at " << path << "output.asm):\n--------------------" << std::endl;
	std::cout << output.str() << "\n(size: " << output.str().size() << ")" << std::endl;
	std::ofstream fp((path + "output.asm").c_str());
	fp.write(output.str().c_str(), output.str().length());
	fp.close();
	ShellExecute(c_hwnd, "open", (path + "fasm.exe").c_str(), ("\"" + path + "output.asm\"").c_str(), 0, SW_SHOW);
	std::cin.ignore();
	std::cin.get();
	return 0;
}
bool check_valid(int& req_cells, const std::string& input, const std::string& fname) {
	bool ret = true;
	unsigned int i, line = 0, pos = 0;
	int ptr_count = 0, max = 0;
	char inlp = 0;
	for(i = 0; i < input.size(); ++i, ++pos) {
		if(input[i] == '\n') {
			pos = 0;
			++line;
		}
		else if(input[i] == '>') {
			++ptr_count;
		}
		else if(input[i] == '<') {
			if(ptr_count > max) max = ptr_count;
			--ptr_count;
		}
		else if(input[i] == '[') {
			++inlp;
		}
		else if(input[i] == ']') {
			--inlp;
			if(inlp < 0) {
				syntax_err("closing a loop not opened", fname, line, pos);
				ret = false;
			}
		}
		if(ptr_count < 0) {
			syntax_err("cell pointer reached below zero", fname, line, pos);
			ret = false;
		}
	}
	req_cells = max;
	return ret;
}
inline void syntax_err(const std::string& message, const std::string& fname, const int& line, const int& pos) {
	std::cerr << fname << "(line " << line << ", pos " << pos << "): syntax error: " << message << std::endl;
}
void replace(std::string& target, const std::string& oldstr, const std::string& newstr) {
	unsigned int x;
	while(x = target.find(oldstr), x != std::string::npos) {
		target.erase(x, oldstr.length());
		target.insert(x, newstr);
	}
}
std::string rstring(int len) {
	static const char alphanum[] = "_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	std::string ret("");
	for(int i = 0; i < len; ++i) {
		ret += alphanum[rand() % 63];
	}
	ret = "_" + ret;
	return ret;
}